{"version":3,"sources":["../src/parser.ts"],"names":[],"mappings":"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","file":"parser.js","sourcesContent":["import * as Promise from \"bluebird\";\r\n\r\nimport Input from \"./input\";\r\nimport Output from \"./output\";\r\nimport Content from \"./content\";\r\n\r\nexport default class Parser<I extends Input, O extends Output, C extends Content> {\r\n    public input: I;\r\n    public output: O;\r\n    public content: C;\r\n\r\n    protected createInput(): Promise<I> {\r\n        return new Promise<I>(resolve => {\r\n            resolve();\r\n        });\r\n    }\r\n\r\n    protected inputCreated(): Promise<void> {\r\n        return new Promise<void>(resolve => {\r\n            resolve();\r\n        });\r\n    }\r\n\r\n    protected createOutput(): Promise<O> {\r\n        return new Promise<O>(resolve => {\r\n            resolve();\r\n        });\r\n    }\r\n\r\n    protected outputCreated(): Promise<void> {\r\n        return new Promise<void>(resolve => {\r\n            resolve();\r\n        });\r\n    }\r\n\r\n    protected createContent(): Promise<C> {\r\n        return new Promise<C>(resolve => {\r\n            resolve();\r\n        });\r\n    }\r\n\r\n    protected contentCreated(): Promise<void> {\r\n        return new Promise<void>(resolve => {\r\n            resolve();\r\n        });\r\n    }\r\n\r\n    public create(inputFactory?: (parser: this) => Promise<I>,\r\n                  outputFactory?: (parser: this) => Promise<O>,\r\n                  contentFactory?: (parser: this) => Promise<C>): Promise<this> {\r\n        let promise = new Promise<any>(resolve => {\r\n            resolve();\r\n        });\r\n\r\n        if (inputFactory) {\r\n            promise = promise\r\n                .then(() => inputFactory(this));\r\n        } else {\r\n            promise = promise\r\n                .then(() => this.createInput());\r\n        }\r\n\r\n        promise = promise\r\n            .then(input => {\r\n                this.input = input;\r\n            })\r\n            .then(() => this.inputCreated());\r\n\r\n        if (outputFactory) {\r\n            promise = promise\r\n                .then(() => outputFactory(this));\r\n        } else {\r\n            promise = promise\r\n                .then(() => this.createOutput());\r\n        }\r\n\r\n        promise = promise\r\n            .then(output => {\r\n                this.output = output;\r\n            })\r\n            .then(() => this.outputCreated());\r\n\r\n        if (contentFactory) {\r\n            promise = promise\r\n                .then(() => contentFactory(this));\r\n        } else {\r\n            promise = promise\r\n                .then(() => this.createContent());\r\n        }\r\n\r\n        promise = promise\r\n            .then(content => {\r\n                this.content = content;\r\n            })\r\n            .then(() => this.contentCreated());\r\n\r\n        return promise\r\n            .then(() => this);\r\n    }\r\n\r\n    public parseValue(valueName: keyof O,\r\n                      valueParser: (parser: this) => Promise<any>): Promise<this> {\r\n        return valueParser(this)\r\n            .then(value => {\r\n                this.output[valueName] = value;\r\n            })\r\n            .then(() => this);\r\n    }\r\n\r\n    public parseValues(valuesName: keyof O,\r\n                       valuesParser: (parser: this, index: number) => Promise<any>,\r\n                       ...indexes: number[]): Promise<this> {\r\n        let indexSet = new Set<number>();\r\n\r\n        for (let index of indexes.sort()) {\r\n            if (index >= 0) {\r\n                indexSet.add(index);\r\n            }\r\n        }\r\n\r\n        let newValues: any[] = [];\r\n\r\n        let values = this.output[valuesName];\r\n\r\n        if (values && Array.isArray(values)) {\r\n            newValues.push(...values);\r\n        }\r\n\r\n        let promise = new Promise<any>(resolve => {\r\n            resolve();\r\n        });\r\n\r\n        for (let index of indexSet) {\r\n            promise = promise\r\n                .then(() => valuesParser(this, index))\r\n                .then(value => {\r\n                    newValues[index] = value;\r\n                });\r\n        }\r\n\r\n        return promise\r\n            .then(() => {\r\n                this.output[valuesName] = newValues;\r\n            })\r\n            .then(() => this);\r\n    }\r\n\r\n    public parseOutput<X extends Input,\r\n        Y extends Output,\r\n        Z extends Content,\r\n        P extends Parser<X, Y, Z>>(outputName: keyof O,\r\n                                   parserFactory: (parser: this) => Promise<P>,\r\n                                   outputParser: (childParser: P) => Promise<any>): Promise<this> {\r\n        return parserFactory(this)\r\n            .then(childParser => {\r\n                let childInput = (this.input as any)[outputName],\r\n                    childOutput = this.output[outputName],\r\n                    childContent = (this.content as any)[outputName];\r\n\r\n                return childParser.create(childInput ? () => new Promise<X>(resolve => {\r\n                    resolve(childInput);\r\n                }) : undefined, childOutput ? () => new Promise<Y>(resolve => {\r\n                    resolve(childOutput);\r\n                }) : undefined, childContent ? () => new Promise<Z>(resolve => {\r\n                    resolve(childContent);\r\n                }) : undefined)\r\n                    .then(() => outputParser(childParser))\r\n                    .then(() => {\r\n                        this.output[outputName] = childParser.output;\r\n                    });\r\n            })\r\n            .then(() => this);\r\n    }\r\n\r\n    public parseOutputs<X extends Input,\r\n        Y extends Output,\r\n        Z extends Content,\r\n        P extends Parser<X, Y, Z>>(outputsName: keyof O,\r\n                                   parserFactory: (parser: this) => Promise<P>,\r\n                                   outputsParser: (childParser: P, index: number) => Promise<any>,\r\n                                   ...indexes: number[]): Promise<this> {\r\n        let inputs = (this.input as any)[outputsName];\r\n\r\n        let inputSize = 0;\r\n\r\n        if (inputs && Array.isArray(inputs)) {\r\n            inputSize = inputs.length;\r\n        }\r\n\r\n        let indexSet = new Set<number>();\r\n\r\n        for (let index of indexes.sort()) {\r\n            if (index >= 0 && (inputSize == 0 || index < inputSize)) {\r\n                indexSet.add(index);\r\n            }\r\n        }\r\n\r\n        if (indexSet.size == 0) {\r\n            for (let i = 0; i < inputSize; i++) {\r\n                indexSet.add(i);\r\n            }\r\n        }\r\n\r\n        let newOutputs: Y[] = [];\r\n\r\n        let outputs = this.output[outputsName];\r\n\r\n        if (outputs && Array.isArray(outputs)) {\r\n            newOutputs.push(...outputs);\r\n        }\r\n\r\n        let contents = (this.content as any)[outputsName];\r\n\r\n        let promise = new Promise<any>(resolve => {\r\n            resolve();\r\n        });\r\n\r\n        for (let index of indexSet) {\r\n            promise = promise\r\n                .then(() => parserFactory(this))\r\n                .then(childParser => {\r\n                    let childInput: X;\r\n\r\n                    if (inputs && Array.isArray(inputs) && index < inputs.length) {\r\n                        childInput = inputs[index];\r\n                    }\r\n\r\n                    let childOutput: Y;\r\n\r\n                    if (outputs && Array.isArray(outputs) && index < outputs.length) {\r\n                        childOutput = outputs[index];\r\n                    }\r\n\r\n                    let childContent: Z;\r\n\r\n                    if (contents && Array.isArray(contents) && index < contents.length) {\r\n                        childContent = contents[index];\r\n                    }\r\n\r\n                    return childParser.create(childInput! ? () => new Promise<X>(resolve => {\r\n                        resolve(childInput);\r\n                    }) : undefined, childOutput! ? () => new Promise<Y>(resolve => {\r\n                        resolve(childOutput);\r\n                    }) : undefined, childContent! ? () => new Promise<Z>(resolve => {\r\n                        resolve(childContent);\r\n                    }) : undefined)\r\n                        .then(() => outputsParser(childParser, index))\r\n                        .then(() => {\r\n                            newOutputs[index] = childParser.output;\r\n                        });\r\n                });\r\n        }\r\n\r\n        return promise\r\n            .then(() => {\r\n                this.output[outputsName] = newOutputs;\r\n            })\r\n            .then(() => this);\r\n    }\r\n}\r\n"]}